#!/usr/bin/env node

const fs = require('fs').promises;
const path = require('path');

async function migrateEnvFile(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    const lines = content.split('\n');
    const env = {};
    
    // Parse existing env
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;
      
      const index = trimmed.indexOf('=');
      if (index > 0) {
        const key = trimmed.substring(0, index).trim();
        const value = trimmed.substring(index + 1).trim();
        env[key] = value.replace(/^["']|["']$/g, '');
      }
    }
    
    // Convert USER_SERVICE to CS_ format
    const serviceCount = parseInt(env.USER_SERVICE_COUNT || '0');
    if (serviceCount > 0) {
      console.log(`Converting ${serviceCount} services to CS_ format...`);
      
      // Add SERVICES_ENABLED
      env.SERVICES_ENABLED = 'true';
      
      for (let i = 1; i <= serviceCount; i++) {
        const name = env[`USER_SERVICE_${i}_NAME`];
        const framework = env[`USER_SERVICE_${i}_FRAMEWORK`];
        const port = env[`USER_SERVICE_${i}_PORT`];
        const route = env[`USER_SERVICE_${i}_ROUTE`] || '';
        
        if (name) {
          // Create CS_N format
          const parts = [name, framework || 'custom', port || (4000 + i - 1), route];
          env[`CS_${i}`] = parts.join(':');
          
          // Remove old format
          delete env[`USER_SERVICE_${i}_NAME`];
          delete env[`USER_SERVICE_${i}_FRAMEWORK`];
          delete env[`USER_SERVICE_${i}_PORT`];
          delete env[`USER_SERVICE_${i}_ROUTE`];
        }
      }
      
      delete env.USER_SERVICE_COUNT;
    }
    
    // Rebuild file with new format
    const newLines = [];
    newLines.push('# nself Configuration - Auto-generated by nself-admin');
    newLines.push(`# Environment: ${env.ENV || 'development'}`);
    newLines.push('');
    
    // Core settings
    const core = ['ENV', 'PROJECT_NAME', 'BASE_DOMAIN', 'PROJECT_DESCRIPTION'];
    const coreValues = core.filter(k => env[k]);
    if (coreValues.length > 0) {
      for (const key of coreValues) {
        newLines.push(`${key}=${env[key]}`);
        delete env[key];
      }
      newLines.push('');
    }
    
    // Database
    const db = ['POSTGRES_DB', 'POSTGRES_USER', 'POSTGRES_PASSWORD', 'DATABASE_TYPE'];
    const dbValues = db.filter(k => env[k]);
    if (dbValues.length > 0) {
      newLines.push('# Database');
      for (const key of dbValues) {
        newLines.push(`${key}=${env[key]}`);
        delete env[key];
      }
      newLines.push('');
    }
    
    // User Services (CS_ format)
    const services = Object.keys(env).filter(k => k.startsWith('CS_') || k === 'SERVICES_ENABLED').sort();
    if (services.length > 0) {
      newLines.push('# User Services');
      for (const key of services) {
        newLines.push(`${key}=${env[key]}`);
        delete env[key];
      }
      newLines.push('');
    }
    
    // Frontend Apps
    const frontend = Object.keys(env).filter(k => k.startsWith('FRONTEND_APP')).sort();
    if (frontend.length > 0) {
      newLines.push('# Frontend Applications');
      for (const key of frontend) {
        newLines.push(`${key}=${env[key]}`);
        delete env[key];
      }
      newLines.push('');
    }
    
    // Remaining
    const remaining = Object.keys(env).sort();
    if (remaining.length > 0) {
      newLines.push('# Additional Settings');
      for (const key of remaining) {
        newLines.push(`${key}=${env[key]}`);
      }
      newLines.push('');
    }
    
    // Write back
    await fs.writeFile(filePath, newLines.join('\n'), 'utf-8');
    console.log(`âœ“ Migrated ${filePath}`);
    
  } catch (error) {
    console.error(`Error migrating ${filePath}:`, error.message);
  }
}

async function main() {
  const projectPath = process.env.NSELF_PROJECT_PATH || '/Users/admin/Sites/nself-project';
  
  const files = [
    path.join(projectPath, '.env.dev'),
    path.join(projectPath, '.env.staging'), 
    path.join(projectPath, '.env.prod'),
    path.join(projectPath, '.env.local')
  ];
  
  for (const file of files) {
    try {
      await fs.access(file);
      await migrateEnvFile(file);
    } catch {
      console.log(`Skipping ${file} (not found)`);
    }
  }
}

main().catch(console.error);