#!/usr/bin/env node

const fs = require('fs').promises;
const path = require('path');

async function migrateEnvFile(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    const lines = content.split('\n');
    const env = {};
    
    // Parse existing env
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;
      
      const index = trimmed.indexOf('=');
      if (index > 0) {
        const key = trimmed.substring(0, index).trim();
        const value = trimmed.substring(index + 1).trim();
        env[key] = value.replace(/^["']|["']$/g, '');
      }
    }
    
    // Migrate frontend app field names
    const appCount = parseInt(env.FRONTEND_APP_COUNT || '0');
    let migrated = false;
    
    for (let i = 1; i <= appCount; i++) {
      // Migrate LOCAL_PORT to PORT
      if (env[`FRONTEND_APP_${i}_LOCAL_PORT`]) {
        env[`FRONTEND_APP_${i}_PORT`] = env[`FRONTEND_APP_${i}_LOCAL_PORT`];
        delete env[`FRONTEND_APP_${i}_LOCAL_PORT`];
        migrated = true;
      }
      
      // Migrate PRODUCTION_URL to ROUTE
      if (env[`FRONTEND_APP_${i}_PRODUCTION_URL`]) {
        env[`FRONTEND_APP_${i}_ROUTE`] = env[`FRONTEND_APP_${i}_PRODUCTION_URL`];
        delete env[`FRONTEND_APP_${i}_PRODUCTION_URL`];
        migrated = true;
      }
      
      // Remove LOCAL_SUBDOMAIN as it's no longer used
      if (env[`FRONTEND_APP_${i}_LOCAL_SUBDOMAIN`]) {
        // If we have a local subdomain but no route, use it as the route
        if (!env[`FRONTEND_APP_${i}_ROUTE`]) {
          env[`FRONTEND_APP_${i}_ROUTE`] = env[`FRONTEND_APP_${i}_LOCAL_SUBDOMAIN`];
        }
        delete env[`FRONTEND_APP_${i}_LOCAL_SUBDOMAIN`];
        migrated = true;
      }
      
      // Auto-generate REMOTE_SCHEMA_NAME if we have URL but no name
      if (env[`FRONTEND_APP_${i}_REMOTE_SCHEMA_URL`] && !env[`FRONTEND_APP_${i}_REMOTE_SCHEMA_NAME`]) {
        const tablePrefix = env[`FRONTEND_APP_${i}_TABLE_PREFIX`];
        if (tablePrefix) {
          env[`FRONTEND_APP_${i}_REMOTE_SCHEMA_NAME`] = `${tablePrefix}_schema`;
          migrated = true;
        }
      }
    }
    
    if (!migrated) {
      console.log(`No migration needed for ${filePath}`);
      return;
    }
    
    // Rebuild file with proper organization
    const newLines = [];
    newLines.push('# nself Configuration - Auto-generated by nself-admin');
    newLines.push(`# Environment: ${env.ENV || 'development'}`);
    newLines.push('');
    
    // Core settings
    const core = ['ENV', 'PROJECT_NAME', 'BASE_DOMAIN', 'PROJECT_DESCRIPTION'];
    const coreValues = core.filter(k => env[k]);
    if (coreValues.length > 0) {
      for (const key of coreValues) {
        newLines.push(`${key}=${env[key]}`);
        delete env[key];
      }
      newLines.push('');
    }
    
    // Database
    const db = ['POSTGRES_DB', 'POSTGRES_USER', 'POSTGRES_PASSWORD'];
    const dbValues = db.filter(k => env[k]);
    if (dbValues.length > 0) {
      newLines.push('# Database');
      for (const key of dbValues) {
        newLines.push(`${key}=${env[key]}`);
        delete env[key];
      }
      newLines.push('');
    }
    
    // Auth & Hasura
    const auth = ['HASURA_GRAPHQL_ADMIN_SECRET', 'HASURA_GRAPHQL_JWT_SECRET', 'AUTH_ENABLED', 'HASURA_ENABLED'];
    const authValues = auth.filter(k => env[k]);
    if (authValues.length > 0) {
      newLines.push('# Authentication & GraphQL');
      for (const key of authValues) {
        newLines.push(`${key}=${env[key]}`);
        delete env[key];
      }
      newLines.push('');
    }
    
    // User Services
    const services = Object.keys(env).filter(k => k.startsWith('CS_') || k === 'SERVICES_ENABLED').sort();
    if (services.length > 0) {
      newLines.push('# User Services');
      for (const key of services) {
        newLines.push(`${key}=${env[key]}`);
        delete env[key];
      }
      newLines.push('');
    }
    
    // Frontend Apps - with new field names
    const frontend = Object.keys(env).filter(k => k.startsWith('FRONTEND_APP')).sort((a, b) => {
      // Sort by app number then field
      const matchA = a.match(/FRONTEND_APP_(\d+)_(.+)/);
      const matchB = b.match(/FRONTEND_APP_(\d+)_(.+)/);
      if (!matchA || !matchB) return a.localeCompare(b);
      
      const numDiff = parseInt(matchA[1]) - parseInt(matchB[1]);
      if (numDiff !== 0) return numDiff;
      
      // Field order
      const order = ['DISPLAY_NAME', 'TABLE_PREFIX', 'PORT', 'ROUTE', 'REMOTE_SCHEMA_NAME', 'REMOTE_SCHEMA_URL'];
      const indexA = order.indexOf(matchA[2]);
      const indexB = order.indexOf(matchB[2]);
      if (indexA === -1 && indexB === -1) return a.localeCompare(b);
      if (indexA === -1) return 1;
      if (indexB === -1) return -1;
      return indexA - indexB;
    });
    
    if (frontend.length > 0) {
      newLines.push('# Frontend Applications');
      // Write count first
      if (env.FRONTEND_APP_COUNT) {
        newLines.push(`FRONTEND_APP_COUNT=${env.FRONTEND_APP_COUNT}`);
        delete env.FRONTEND_APP_COUNT;
      }
      for (const key of frontend) {
        newLines.push(`${key}=${env[key]}`);
        delete env[key];
      }
      newLines.push('');
    }
    
    // Optional Services
    const optional = ['REDIS_ENABLED', 'MINIO_ENABLED', 'MONITORING_ENABLED', 'MLFLOW_ENABLED', 'MAILPIT_ENABLED', 'SEARCH_ENABLED', 'ELASTICSEARCH_ENABLED'];
    const optionalValues = optional.filter(k => env[k]);
    if (optionalValues.length > 0) {
      newLines.push('# Optional Services');
      for (const key of optionalValues) {
        newLines.push(`${key}=${env[key]}`);
        delete env[key];
      }
      newLines.push('');
    }
    
    // Backup
    const backup = ['DB_BACKUP_ENABLED', 'DB_BACKUP_SCHEDULE', 'DB_BACKUP_RETENTION_DAYS'];
    const backupValues = backup.filter(k => env[k]);
    if (backupValues.length > 0) {
      newLines.push('# Backup');
      for (const key of backupValues) {
        newLines.push(`${key}=${env[key]}`);
        delete env[key];
      }
      newLines.push('');
    }
    
    // Remaining
    const remaining = Object.keys(env).sort();
    if (remaining.length > 0) {
      newLines.push('# Additional Settings');
      for (const key of remaining) {
        newLines.push(`${key}=${env[key]}`);
      }
      newLines.push('');
    }
    
    // Write back
    await fs.writeFile(filePath, newLines.join('\n'), 'utf-8');
    console.log(`âœ“ Migrated frontend apps in ${filePath}`);
    
  } catch (error) {
    console.error(`Error migrating ${filePath}:`, error.message);
  }
}

async function main() {
  const projectPath = process.env.NSELF_PROJECT_PATH || '/Users/admin/Sites/nself-project';
  
  const files = [
    path.join(projectPath, '.env.dev'),
    path.join(projectPath, '.env.staging'), 
    path.join(projectPath, '.env.prod'),
    path.join(projectPath, '.env.local')
  ];
  
  for (const file of files) {
    try {
      await fs.access(file);
      await migrateEnvFile(file);
    } catch {
      console.log(`Skipping ${file} (not found)`);
    }
  }
}

main().catch(console.error);