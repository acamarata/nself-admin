import fs from 'fs/promises'
import path from 'path'
import { getProjectPath } from './paths'

interface EnvConfig {
  [key: string]: string
}

// Read env files in priority order and merge them
export async function readEnvFile(): Promise<EnvConfig | null> {
  try {
    const projectPath = getProjectPath()
    let config: EnvConfig = {}
    
    // Helper to parse env file content
    const parseEnvContent = (content: string): EnvConfig => {
      const result: EnvConfig = {}
      const lines = content.split('\n')
      for (const line of lines) {
        const trimmed = line.trim()
        if (!trimmed || trimmed.startsWith('#')) continue
        
        const index = trimmed.indexOf('=')
        if (index > 0) {
          const key = trimmed.substring(0, index).trim()
          const value = trimmed.substring(index + 1).trim()
          // Remove quotes if present
          result[key] = value.replace(/^["']|["']$/g, '')
        }
      }
      return result
    }
    
    // Read files in nself priority order (later files override earlier ones)  
    // File Loading Order from nself:
    // 1) .env.dev     (team defaults, SHARED)
    // 2) .env.staging (staging only config, SHARED)  
    // 3) .env.prod    (production only config, SHARED)
    // 4) .env.secrets (production secrets, not shared)
    // 5) .env         (LOCAL ONLY priority overrides - highest priority)
    
    // 1. Read .env.dev (team defaults)
    try {
      const devPath = path.join(projectPath, '.env.dev')
      const content = await fs.readFile(devPath, 'utf-8')
      config = { ...config, ...parseEnvContent(content) }
    } catch {
      // File may not exist
    }
    
    // 2. Read .env.staging (staging config)
    try {
      const stagingPath = path.join(projectPath, '.env.staging')
      const content = await fs.readFile(stagingPath, 'utf-8')
      config = { ...config, ...parseEnvContent(content) }
    } catch {
      // File may not exist
    }
    
    // 3. Read .env.prod (production config)
    try {
      const prodPath = path.join(projectPath, '.env.prod')
      const content = await fs.readFile(prodPath, 'utf-8')
      config = { ...config, ...parseEnvContent(content) }
    } catch {
      // File may not exist
    }
    
    // 4. Read .env.secrets (production secrets)
    try {
      const secretsPath = path.join(projectPath, '.env.secrets')
      const content = await fs.readFile(secretsPath, 'utf-8')
      config = { ...config, ...parseEnvContent(content) }
    } catch {
      // File may not exist
    }
    
    // 5. Read .env (LOCAL ONLY priority overrides - highest priority)
    try {
      const envPath = path.join(projectPath, '.env')
      const content = await fs.readFile(envPath, 'utf-8')
      config = { ...config, ...parseEnvContent(content) }
    } catch {
      // File may not exist
    }
    
    return Object.keys(config).length > 0 ? config : null
  } catch (error) {
    console.error('Error reading env files:', error)
    return null
  }
}

// Write to environment-specific file based on ENV setting
export async function writeEnvFile(config: EnvConfig): Promise<void> {
  const projectPath = getProjectPath()
  
  // Determine which file to write based on environment
  const env = config.ENV || config.ENVIRONMENT || 'development'
  
  // Write to environment-specific file based on ENV setting
  // Per nself guidance: write to .env.dev for development, NOT .env (which is for local overrides only)
  let envFileName: string
  switch(env) {
    case 'development':
    case 'dev':
      envFileName = '.env.dev'
      break
    case 'staging':
      envFileName = '.env.staging'
      break
    case 'production':
    case 'prod':
      envFileName = '.env.prod'
      break
    default:
      envFileName = '.env.dev'
  }
  
  const envPath = path.join(projectPath, envFileName)
  
  // Build the env file content with better organization
  const lines: string[] = []
  
  // Minimal header
  lines.push('# nself Configuration - Auto-generated by nself-admin')
  lines.push(`# Environment: ${env}`)
  lines.push('')
  
  // Core Settings (always at top, no comments needed)
  const coreSettings = ['ENV', 'PROJECT_NAME', 'BASE_DOMAIN', 'PROJECT_DESCRIPTION']
  const coreValues = coreSettings.filter(key => config[key] !== undefined && config[key] !== '')
  if (coreValues.length > 0) {
    for (const key of coreValues) {
      lines.push(`${key}=${config[key]}`)
    }
    lines.push('')
  }
  
  // Database Configuration
  const dbSettings = ['POSTGRES_DB', 'POSTGRES_USER', 'POSTGRES_PASSWORD']
  const dbValues = dbSettings.filter(key => config[key] !== undefined)
  if (dbValues.length > 0) {
    lines.push('# Database')
    for (const key of dbValues) {
      lines.push(`${key}=${config[key]}`)
    }
    lines.push('')
  }
  
  // Hasura Settings - per spec v1.0
  const hasuraSettings = ['HASURA_GRAPHQL_ADMIN_SECRET', 'HASURA_JWT_KEY', 'HASURA_JWT_TYPE', 'HASURA_GRAPHQL_JWT_SECRET']
  const hasuraValues = hasuraSettings.filter(key => config[key] !== undefined)
  if (hasuraValues.length > 0) {
    lines.push('# Hasura GraphQL')
    for (const key of hasuraValues) {
      lines.push(`${key}=${config[key]}`)
    }
    lines.push('')
  }
  
  // Custom Services - Dynamic based on actual services
  const serviceKeys = Object.keys(config).filter(key => key.startsWith('CS_') || key === 'SERVICES_ENABLED')
  // Also filter out old USER_SERVICE_* keys if we have CS_* keys
  const hasNewFormat = serviceKeys.some(key => key.startsWith('CS_'))
  const oldServiceKeys = Object.keys(config).filter(key => key.startsWith('USER_SERVICE'))
  
  if (serviceKeys.length > 0) {
    lines.push('# Custom Services')
    // Sort CS_1, CS_2, etc numerically
    const sortedServices = serviceKeys.sort((a, b) => {
      const numA = parseInt(a.replace('CS_', '') || '0')
      const numB = parseInt(b.replace('CS_', '') || '0')
      if (a === 'SERVICES_ENABLED') return -1
      if (b === 'SERVICES_ENABLED') return 1
      return numA - numB
    })
    for (const key of sortedServices) {
      lines.push(`${key}=${config[key]}`)
    }
    lines.push('')
  } else if (!hasNewFormat && oldServiceKeys.length > 0) {
    // Keep old format if no new format exists (backwards compatibility)
    lines.push('# Custom Services (Legacy Format)')
    for (const key of oldServiceKeys.sort()) {
      lines.push(`${key}=${config[key]}`)
    }
    lines.push('')
  }
  
  // Frontend Apps - Dynamic based on actual apps
  const frontendKeys = Object.keys(config).filter(key => key.startsWith('FRONTEND_APP'))
  if (frontendKeys.length > 0) {
    lines.push('# Frontend Applications')
    // Sort by app number then by field
    const sortedFrontend = frontendKeys.sort((a, b) => {
      if (a === 'FRONTEND_APP_COUNT') return -1
      if (b === 'FRONTEND_APP_COUNT') return 1
      const matchA = a.match(/FRONTEND_APP_(\d+)_(.+)/)
      const matchB = b.match(/FRONTEND_APP_(\d+)_(.+)/)
      if (matchA && matchB) {
        const numDiff = parseInt(matchA[1]) - parseInt(matchB[1])
        if (numDiff !== 0) return numDiff
        // Order fields consistently
        const fieldOrder = ['DISPLAY_NAME', 'SYSTEM_NAME', 'TABLE_PREFIX', 'PORT', 'ROUTE', 'REMOTE_SCHEMA_NAME', 'REMOTE_SCHEMA_URL']
        const indexA = fieldOrder.indexOf(matchA[2])
        const indexB = fieldOrder.indexOf(matchB[2])
        return indexA - indexB
      }
      return a.localeCompare(b)
    })
    for (const key of sortedFrontend) {
      lines.push(`${key}=${config[key]}`)
    }
    lines.push('')
  }
  
  // Service Enable Flags - per spec v1.0 include core services
  const serviceFlags = [
    'POSTGRES_ENABLED', 'HASURA_ENABLED', 'AUTH_ENABLED', 'STORAGE_ENABLED',  // Core services  
    'NSELF_ADMIN_ENABLED', 'REDIS_ENABLED', 'MLFLOW_ENABLED', 'MAILPIT_ENABLED', 'SEARCH_ENABLED',  // Optional services
    'PROMETHEUS_ENABLED', 'GRAFANA_ENABLED', 'LOKI_ENABLED', 'MONITORING_ENABLED'  // Monitoring bundle
  ]
  const enabledServices = serviceFlags.filter(key => config[key] === 'true')
  const disabledServices = serviceFlags.filter(key => config[key] === 'false')
  
  if (enabledServices.length > 0 || disabledServices.length > 0) {
    lines.push('# Service Enable Flags')
    // Write enabled services first
    for (const key of enabledServices) {
      lines.push(`${key}=true`)
    }
    // Then disabled ones
    for (const key of disabledServices) {
      lines.push(`${key}=false`)
    }
    lines.push('')
  }
  
  // Backup Settings (only if enabled)
  if (config.BACKUP_ENABLED === 'true' || config.DB_BACKUP_ENABLED === 'true') {
    lines.push('# Backup Configuration')
    const backupKeys = ['BACKUP_ENABLED', 'BACKUP_SCHEDULE', 'BACKUP_RETENTION_DAYS', 'BACKUP_DIR', 'BACKUP_COMPRESSION', 'BACKUP_ENCRYPTION']
    for (const key of backupKeys) {
      if (config[key] !== undefined) {
        lines.push(`${key}=${config[key]}`)
      }
    }
    lines.push('')
  } else if (config.BACKUP_ENABLED === 'false' || config.DB_BACKUP_ENABLED === 'false') {
    lines.push('# Backup')
    lines.push('BACKUP_ENABLED=false')
    lines.push('')
  }
  
  // Any remaining variables not in above categories
  const handledKeys = new Set([
    ...coreSettings, ...dbSettings, ...hasuraSettings, 
    ...serviceKeys, ...frontendKeys, ...serviceFlags,
    'BACKUP_ENABLED', 'BACKUP_SCHEDULE', 'BACKUP_RETENTION_DAYS', 'BACKUP_DIR', 'BACKUP_COMPRESSION', 'BACKUP_ENCRYPTION',
    'DB_BACKUP_ENABLED', 'DB_BACKUP_SCHEDULE', 'DB_BACKUP_RETENTION_DAYS', 'DB_BACKUP_STORAGE', // Also handle old format
    'HASURA_GRAPHQL_JWT_SECRET'  // Old format
  ])
  
  const remainingKeys = Object.keys(config).filter(key => !handledKeys.has(key))
  if (remainingKeys.length > 0) {
    lines.push('# Additional Settings')
    for (const key of remainingKeys.sort()) {
      lines.push(`${key}=${config[key]}`)
    }
    lines.push('')
  }
  
  // Write to environment-specific file
  await fs.writeFile(envPath, lines.join('\n'), 'utf-8')
  
  console.log(`Updated ${envFileName} for environment: ${env}`)
  
  // Debug: log what was written
  console.log('Wrote config with PROJECT_NAME:', config.PROJECT_NAME)
}

// Update specific env variables
export async function updateEnvFile(updates: EnvConfig): Promise<void> {
  const existing = await readEnvFile() || {}
  const merged = { ...existing, ...updates }
  await writeEnvFile(merged)
}

// Check if appropriate env file exists for current environment
export async function envFileExists(environment?: string): Promise<boolean> {
  try {
    const projectPath = getProjectPath()
    const env = environment || 'development'
    
    // Check the appropriate file based on environment
    let fileName = '.env.dev'
    switch(env) {
      case 'development':
      case 'dev':
        fileName = '.env.dev'
        break
      case 'staging':
        fileName = '.env.staging'
        break
      case 'production':
      case 'prod':
        fileName = '.env.prod'
        break
    }
    
    const envPath = path.join(projectPath, fileName)
    await fs.access(envPath)
    return true
  } catch {
    return false
  }
}

// Convert wizard config to env variables
export function wizardConfigToEnv(config: any): EnvConfig {
  const env: EnvConfig = {}
  
  // Basic settings - per nself docs, use ENV not ENVIRONMENT
  env.PROJECT_NAME = config.projectName || 'nproject'
  env.PROJECT_DESCRIPTION = config.projectDescription || ''
  env.ENV = config.environment || 'development'  // nself uses ENV, not ENVIRONMENT
  env.BASE_DOMAIN = config.domain || 'local.nself.org'  // nself default domain
  
  // Core services are enabled by default per spec v1.0
  env.POSTGRES_ENABLED = 'true'  // Always true per spec for backward compatibility
  env.HASURA_ENABLED = 'true'  // Always true per spec for backward compatibility
  env.AUTH_ENABLED = 'true'  // Always true per spec for backward compatibility
  env.STORAGE_ENABLED = 'true'  // Default true per spec
  
  // Database - nself uses POSTGRES_DB and POSTGRES_PASSWORD
  env.POSTGRES_DB = config.databaseName || 'nself'  // nself default db name
  env.POSTGRES_PASSWORD = config.databasePassword || 'nself-dev-password'
  env.POSTGRES_USER = 'postgres'  // nself always uses postgres user
  
  // Hasura Configuration - per spec v1.0 use HASURA_JWT_KEY not full JWT_SECRET
  env.HASURA_GRAPHQL_ADMIN_SECRET = config.hasuraAdminSecret || 'hasura-admin-secret-dev'
  env.HASURA_JWT_KEY = config.jwtSecret || 'development-secret-key-minimum-32-characters-long'
  env.HASURA_JWT_TYPE = 'HS256'  // Default per spec
  
  // Optional services - these default to false unless explicitly enabled
  if (config.optionalServices) {
    // Storage is special - already defaulted to true above, can be overridden
    if (config.optionalServices.minio !== undefined || config.optionalServices.storage !== undefined) {
      env.STORAGE_ENABLED = (config.optionalServices.minio || config.optionalServices.storage) ? 'true' : 'false'
    }
    // These default to false (in order: nself-admin, redis, minio, mlflow, mail, search, monitoring)
    env.NSELF_ADMIN_ENABLED = (config.optionalServices.nadmin || config.optionalServices.admin) ? 'true' : 'false'
    env.REDIS_ENABLED = config.optionalServices.redis ? 'true' : 'false'
    env.MLFLOW_ENABLED = config.optionalServices.mlflow ? 'true' : 'false'
    env.MAILPIT_ENABLED = (config.optionalServices.mail?.enabled || config.optionalServices.mailpit) ? 'true' : 'false'
    env.SEARCH_ENABLED = config.optionalServices.search ? 'true' : 'false'
    // Monitoring bundle - can use individual or bundle flag
    if (config.optionalServices.monitoring) {
      env.MONITORING_ENABLED = 'true'  // Bundle flag sets all three per spec
      env.PROMETHEUS_ENABLED = 'true'
      env.GRAFANA_ENABLED = 'true'
      env.LOKI_ENABLED = 'true'
    } else {
      env.MONITORING_ENABLED = 'false'
      env.PROMETHEUS_ENABLED = 'false'
      env.GRAFANA_ENABLED = 'false'
      env.LOKI_ENABLED = 'false'
    }
  }
  
  // Custom services - Use nself CLI format (CS_N=name:framework:port:route)
  if (config.customServices && config.customServices.length > 0) {
    // First enable services
    env.SERVICES_ENABLED = 'true'
    
    config.customServices.forEach((service: any, index: number) => {
      const num = index + 1
      // Build the CS_N value in format: name:framework:port:route
      const parts = [
        service.name,
        service.framework,
        service.port || (3000 + num),
        service.route || ''  // Empty route is fine
      ]
      env[`CS_${num}`] = parts.join(':')
    })
  }
  
  // Frontend apps
  if (config.frontendApps && config.frontendApps.length > 0) {
    env.FRONTEND_APP_COUNT = String(config.frontendApps.length)
    config.frontendApps.forEach((app: any, index: number) => {
      const num = index + 1
      env[`FRONTEND_APP_${num}_DISPLAY_NAME`] = app.displayName || ''
      env[`FRONTEND_APP_${num}_SYSTEM_NAME`] = app.systemName || ''
      env[`FRONTEND_APP_${num}_TABLE_PREFIX`] = app.tablePrefix || ''
      
      // Port for local development
      if (app.localPort) {
        env[`FRONTEND_APP_${num}_PORT`] = String(app.localPort)
      }
      
      // Route (subdomain in dev, can be full domain in prod)
      if (app.productionUrl) {
        env[`FRONTEND_APP_${num}_ROUTE`] = app.productionUrl
      }
      
      // Remote schema configuration for Hasura
      if (app.remoteSchemaUrl) {
        env[`FRONTEND_APP_${num}_REMOTE_SCHEMA_URL`] = app.remoteSchemaUrl
        // Auto-generate schema name from table prefix if not provided
        if (!app.remoteSchemaName && app.tablePrefix) {
          env[`FRONTEND_APP_${num}_REMOTE_SCHEMA_NAME`] = `${app.tablePrefix}_schema`
        } else if (app.remoteSchemaName) {
          env[`FRONTEND_APP_${num}_REMOTE_SCHEMA_NAME`] = app.remoteSchemaName
        }
      }
    })
  }
  
  // Backup settings - use nself's BACKUP_* naming
  if (config.backupEnabled !== undefined) {
    env.BACKUP_ENABLED = config.backupEnabled ? 'true' : 'false'
    if (config.backupEnabled) {
      env.BACKUP_SCHEDULE = config.backupSchedule || '0 2 * * *'
      env.BACKUP_RETENTION_DAYS = String(config.backupRetentionDays || 7)
      env.BACKUP_DIR = config.backupDir || '/backups'
      if (config.backupCompression) env.BACKUP_COMPRESSION = 'true'
      if (config.backupEncryption) env.BACKUP_ENCRYPTION = 'true'
    }
  }
  
  return env
}

// Convert env variables to wizard config
export function envToWizardConfig(env: EnvConfig): any {
  const config: any = {
    projectName: env.PROJECT_NAME || 'nproject',
    projectDescription: env.PROJECT_DESCRIPTION || '',
    environment: env.ENV || 'development',  // nself uses ENV, not ENVIRONMENT
    domain: env.BASE_DOMAIN || 'local.nself.org',
    databaseName: env.POSTGRES_DB || 'nself',
    databasePassword: env.POSTGRES_PASSWORD || 'nself-dev-password',
    hasuraAdminSecret: env.HASURA_GRAPHQL_ADMIN_SECRET || 'hasura-admin-secret-dev',
    jwtSecret: env.HASURA_JWT_KEY || (() => {
      // For backward compatibility, try to extract from old JWT_SECRET format
      if (env.HASURA_GRAPHQL_JWT_SECRET) {
        try {
          const parsed = JSON.parse(env.HASURA_GRAPHQL_JWT_SECRET)
          return parsed.key || 'development-secret-key-minimum-32-characters-long'
        } catch {
          return env.HASURA_GRAPHQL_JWT_SECRET
        }
      }
      return 'development-secret-key-minimum-32-characters-long'
    })(),
    backupEnabled: env.BACKUP_ENABLED === 'true' || env.DB_BACKUP_ENABLED === 'true', // Support both for backwards compat
    backupSchedule: env.BACKUP_SCHEDULE || env.DB_BACKUP_SCHEDULE || '0 2 * * *',
    
    // Pass through all raw env variables so the page can read them
    ...env,
    
    // Initialize nested objects
    postgres: {
      version: '16-alpine',
      port: 5432,
      maxConnections: 100,
      poolingEnabled: 'auto'
    },
    hasura: {
      version: 'v2.44.0',
      consoleEnabled: true,
      devMode: true,
      cors: '*'
    },
    nginx: {
      sslMode: 'local',
      httpPort: 80,
      httpsPort: 443
    },
    auth: {
      jwtExpiresIn: 900,
      refreshExpiresIn: 2592000,
      smtpHost: 'mailpit',
      smtpPort: 1025,
      smtpSender: 'noreply@localhost'
    },
    storage: {
      accessKey: 'storage-access-key-dev',
      secretKey: 'storage-secret-key-dev',
      bucket: 'nself',
      region: 'us-east-1'
    },
    
    // Optional services - per spec v1.0 (in order: nself-admin, redis, minio, mlflow, mail, search, monitoring)
    optionalServices: {
      admin: env.NSELF_ADMIN_ENABLED === 'true' || env.NADMIN_ENABLED === 'true',  // Support both
      redis: env.REDIS_ENABLED === 'true',
      minio: env.STORAGE_ENABLED === 'true' || env.MINIO_ENABLED === 'true', // Support both for backwards compat
      storage: env.STORAGE_ENABLED === 'true',  // Use storage as primary name
      mlflow: env.MLFLOW_ENABLED === 'true',
      mail: {
        enabled: env.MAILPIT_ENABLED === 'true',
        provider: env.EMAIL_PROVIDER || 'mailpit'
      },
      search: env.SEARCH_ENABLED === 'true',
      monitoring: env.MONITORING_ENABLED === 'true' || (env.PROMETHEUS_ENABLED === 'true' && env.GRAFANA_ENABLED === 'true')
    },
    
    // Custom services
    customServices: [],
    
    // Frontend apps
    frontendApps: []
  }
  
  // Parse custom services - support both formats for backwards compatibility
  // 1. Try nself CLI format (CS_N)
  for (let i = 1; i <= 99; i++) {  // Check up to 99 services (nself supports CS_1 through CS_99)
    const serviceDef = env[`CS_${i}`]
    if (serviceDef) {
      const [name, framework, port, route] = serviceDef.split(':')
      if (name) {
        config.customServices.push({
          name,
          framework: framework || 'custom',
          port: port ? parseInt(port) : (4000 + i - 1),
          route: route || undefined
        })
      }
    }
  }
  
  // 2. If no CS_N format found, try old USER_SERVICE_N format for backwards compatibility
  if (config.customServices.length === 0) {
    const serviceCount = parseInt(env.USER_SERVICE_COUNT || '0')
    for (let i = 1; i <= serviceCount; i++) {
      const name = env[`USER_SERVICE_${i}_NAME`]
      const framework = env[`USER_SERVICE_${i}_FRAMEWORK`]
      const port = env[`USER_SERVICE_${i}_PORT`]
      const route = env[`USER_SERVICE_${i}_ROUTE`]
      
      if (name) {
        config.customServices.push({
          name,
          framework: framework || 'custom',
          port: port ? parseInt(port) : (4000 + i - 1),
          route: route || undefined
        })
      }
    }
  }
  
  // Parse frontend apps
  const frontendAppCount = parseInt(env.FRONTEND_APP_COUNT || '0')
  for (let i = 1; i <= frontendAppCount; i++) {
    const displayName = env[`FRONTEND_APP_${i}_DISPLAY_NAME`]
    const systemName = env[`FRONTEND_APP_${i}_SYSTEM_NAME`]
    const tablePrefix = env[`FRONTEND_APP_${i}_TABLE_PREFIX`]
    
    // Only add if we have at least a display name or table prefix
    if (displayName || tablePrefix) {
      config.frontendApps.push({
        displayName: displayName || '',
        systemName: systemName || '',
        tablePrefix: tablePrefix || '',
        localPort: env[`FRONTEND_APP_${i}_PORT`] || env[`FRONTEND_APP_${i}_LOCAL_PORT`] ? 
          parseInt(env[`FRONTEND_APP_${i}_PORT`] || env[`FRONTEND_APP_${i}_LOCAL_PORT`]) : undefined,
        productionUrl: env[`FRONTEND_APP_${i}_ROUTE`] || env[`FRONTEND_APP_${i}_PRODUCTION_URL`] || undefined,
        remoteSchemaName: env[`FRONTEND_APP_${i}_REMOTE_SCHEMA_NAME`] || undefined,
        remoteSchemaUrl: env[`FRONTEND_APP_${i}_REMOTE_SCHEMA_URL`] || undefined
      })
    }
  }
  
  return config
}