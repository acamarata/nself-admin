import { NextRequest, NextResponse } from 'next/server'
import path from 'path'
import { promises as fs } from 'fs'

export async function POST(req: NextRequest) {
  try {
    // Get project path
    const projectPath = process.env.NSELF_PROJECT_PATH || process.env.PROJECT_PATH || '../nself-project'
    
    let absoluteProjectPath: string
    if (path.isAbsolute(projectPath)) {
      absoluteProjectPath = projectPath
    } else {
      // Handle relative path properly - expand ~ to home directory
      if (projectPath.startsWith('~/')) {
        const homedir = process.env.HOME || process.env.USERPROFILE || ''
        absoluteProjectPath = path.join(homedir, projectPath.slice(2))
      } else {
        absoluteProjectPath = path.resolve(process.cwd(), projectPath)
      }
    }
    
    console.log('Resetting project files...')
    
    // Remove key files to reset project state
    const filesToRemove = [
      'docker-compose.yml',
      'docker-compose.monitoring.yml', 
      'docker-compose.custom.yml',
      '.env.dev',
      '.env.staging',
      '.env.prod'
    ]
    
    let removedFiles = []
    let errors = []
    
    for (const file of filesToRemove) {
      try {
        const filePath = path.join(absoluteProjectPath, file)
        await fs.unlink(filePath)
        removedFiles.push(file)
      } catch (error: any) {
        if (error.code !== 'ENOENT') { // Ignore "file not found" errors
          errors.push(`${file}: ${error.message}`)
        }
      }
    }
    
    // Create fresh .env.dev file with basic settings
    const basicEnvContent = `# nself Configuration - Auto-generated by nself-admin
# Environment: dev

ENV=dev
PROJECT_NAME=nself-project
BASE_DOMAIN=localhost

# Database
POSTGRES_DB=nself
POSTGRES_USER=postgres
POSTGRES_PASSWORD=nself-dev-password

# Hasura GraphQL
HASURA_GRAPHQL_ADMIN_SECRET=hasura-admin-secret-dev
HASURA_JWT_KEY=development-secret-key-minimum-32-characters-long
HASURA_JWT_TYPE=HS256
HASURA_METADATA_DATABASE_URL=postgres://postgres:nself-dev-password@postgres:5432/nself

# Custom Services
SERVICES_ENABLED=false

# Frontend Applications
FRONTEND_APP_COUNT=1
FRONTEND_APP_1_DISPLAY_NAME="App 1"
FRONTEND_APP_1_SYSTEM_NAME=app_1
FRONTEND_APP_1_TABLE_PREFIX=app1
FRONTEND_APP_1_PORT=3001
FRONTEND_APP_1_ROUTE=app1
FRONTEND_APP_1_REMOTE_SCHEMA_NAME=app1_schema
FRONTEND_APP_1_REMOTE_SCHEMA_URL=api.app1

# Service Enable Flags
POSTGRES_ENABLED=true
HASURA_ENABLED=true
AUTH_ENABLED=true
STORAGE_ENABLED=true
REDIS_ENABLED=false
MLFLOW_ENABLED=false
MAILPIT_ENABLED=false
SEARCH_ENABLED=false
PROMETHEUS_ENABLED=false
GRAFANA_ENABLED=false
LOKI_ENABLED=false
TEMPO_ENABLED=false
ALERTMANAGER_ENABLED=false
MONITORING_ENABLED=false
NSELF_ADMIN_ENABLED=false

# Service Credentials
MINIO_ROOT_USER=minioadmin
MINIO_ROOT_PASSWORD=minioadmin-password
MEILI_MASTER_KEY=meilisearch-master-key-32-chars
GRAFANA_ADMIN_PASSWORD=grafana-admin-password

# Backup Configuration
BACKUP_ENABLED=true
BACKUP_SCHEDULE="0 00 02 * * *"
BACKUP_RETENTION_DAYS=7
BACKUP_DIR=/backups

# Additional Settings
DATABASE_TYPE=PostgreSQL
POSTGRES_HOST=postgres
POSTGRES_PORT=5433
`
    
    try {
      const envPath = path.join(absoluteProjectPath, '.env.dev')
      await fs.writeFile(envPath, basicEnvContent, 'utf8')
    } catch (error: any) {
      errors.push(`Failed to create .env.dev: ${error.message}`)
    }
    
    return NextResponse.json({ 
      success: true, 
      message: 'Project reset successfully',
      details: {
        removedFiles,
        errors: errors.length > 0 ? errors : undefined,
        message: 'Project has been reset to initial state. You can now go through the setup wizard again.'
      }
    })
  } catch (error: any) {
    console.error('Error resetting project:', error)
    return NextResponse.json(
      { error: 'Failed to reset project', details: error.message },
      { status: 500 }
    )
  }
}