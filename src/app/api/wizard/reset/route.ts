import { getProjectPath } from '@/lib/paths'
import { exec } from 'child_process'
import { promises as fs } from 'fs'
import { NextRequest, NextResponse } from 'next/server'
import path from 'path'
import { promisify } from 'util'

const execAsync = promisify(exec)

export async function POST(req: NextRequest) {
  try {
    // Get project path using centralized resolution
    // getProjectPath() already handles tilde expansion and relative paths
    const absoluteProjectPath = getProjectPath()

    console.log('Resetting project with nself reset command...')

    // Use nself from PATH first, fallback to known location
    let nselfCommand = 'nself'

    // Check if nself is in PATH
    try {
      await execAsync('which nself')
      console.log('Using nself from PATH')
    } catch {
      // Fallback to known location
      const nselfSourcePath = '/Users/admin/Sites/nself'
      const nselfPath = path.join(nselfSourcePath, 'bin', 'nself')

      try {
        await fs.access(nselfPath)
        nselfCommand = nselfPath
        console.log('Using nself from:', nselfPath)
      } catch {
        console.error('nself CLI not found')
        return NextResponse.json(
          { error: 'nself CLI not found. Please ensure nself is installed.' },
          { status: 500 },
        )
      }
    }

    // Execute nself reset command with force flag
    try {
      const { stdout, stderr } = await execAsync(
        `echo "Y" | ${nselfCommand} reset --force`,
        {
          cwd: absoluteProjectPath,
          env: {
            ...process.env,
            PATH: `${process.env.PATH}:/Users/admin/bin:/usr/local/bin:/opt/homebrew/bin`,
            // Keep the terminal environment clean to preserve nself's native output
          },
          maxBuffer: 10 * 1024 * 1024, // 10MB buffer for output
          timeout: 30000, // 30 second timeout
        },
      )

      console.log('=== Reset Output ===')
      console.log('stdout:', stdout)
      if (stderr) {
        console.log('stderr:', stderr)
      }

      return NextResponse.json({
        success: true,
        message: 'Project reset successfully',
        details: {
          output: stdout || 'Project reset completed',
          message:
            'Project has been reset using nself reset. All containers, volumes, and configuration have been removed.',
        },
      })
    } catch (execError: any) {
      console.error('=== Reset Error ===')
      console.error('Error code:', execError.code)
      console.error('Error message:', execError.message)
      console.error('stdout:', execError.stdout)
      console.error('stderr:', execError.stderr)

      // If nself reset fails, fall back to manual cleanup
      console.log('Falling back to manual cleanup...')

      // Remove key files to reset project state
      const filesToRemove = [
        'docker-compose.yml',
        'docker-compose.monitoring.yml',
        'docker-compose.custom.yml',
        '.env.dev',
        '.env.staging',
        '.env.prod',
      ]

      let removedFiles = []
      let errors = []

      for (const file of filesToRemove) {
        try {
          const filePath = path.join(absoluteProjectPath, file)
          await fs.unlink(filePath)
          removedFiles.push(file)
        } catch (error: any) {
          if (error.code !== 'ENOENT') {
            // Ignore "file not found" errors
            errors.push(`${file}: ${error.message}`)
          }
        }
      }

      // Create fresh .env.dev file with basic settings
      const basicEnvContent = `# nself Configuration - Auto-generated by nself-admin
# Environment: dev

ENV=dev
PROJECT_NAME=nself-project
BASE_DOMAIN=localhost

# Database
POSTGRES_DB=nself
POSTGRES_USER=postgres
POSTGRES_PASSWORD=nself-dev-password

# Hasura GraphQL
HASURA_GRAPHQL_ADMIN_SECRET=hasura-admin-secret-dev
HASURA_JWT_KEY=development-secret-key-minimum-32-characters-long
HASURA_JWT_TYPE=HS256
HASURA_METADATA_DATABASE_URL=postgres://postgres:nself-dev-password@postgres:5432/nself

# Custom Services
SERVICES_ENABLED=false

# Frontend Applications
FRONTEND_APP_COUNT=1
FRONTEND_APP_1_DISPLAY_NAME="App 1"
FRONTEND_APP_1_SYSTEM_NAME=app_1
FRONTEND_APP_1_TABLE_PREFIX=app1
FRONTEND_APP_1_PORT=3001
FRONTEND_APP_1_ROUTE=app1
FRONTEND_APP_1_REMOTE_SCHEMA_NAME=app1_schema
FRONTEND_APP_1_REMOTE_SCHEMA_URL=api.app1

# Service Enable Flags
POSTGRES_ENABLED=true
HASURA_ENABLED=true
AUTH_ENABLED=true
STORAGE_ENABLED=true
REDIS_ENABLED=false
MLFLOW_ENABLED=false
MAILPIT_ENABLED=false
SEARCH_ENABLED=false
PROMETHEUS_ENABLED=false
GRAFANA_ENABLED=false
LOKI_ENABLED=false
TEMPO_ENABLED=false
ALERTMANAGER_ENABLED=false
MONITORING_ENABLED=false
NSELF_ADMIN_ENABLED=false

# Service Credentials
MINIO_ROOT_USER=minioadmin
MINIO_ROOT_PASSWORD=minioadmin-password
MEILI_MASTER_KEY=meilisearch-master-key-32-chars
GRAFANA_ADMIN_PASSWORD=grafana-admin-password

# Backup Configuration
BACKUP_ENABLED=true
BACKUP_SCHEDULE="0 00 02 * * *"
BACKUP_RETENTION_DAYS=7
BACKUP_DIR=/backups

# Additional Settings
DATABASE_TYPE=PostgreSQL
POSTGRES_HOST=postgres
POSTGRES_PORT=5433
`

      try {
        const envPath = path.join(absoluteProjectPath, '.env.dev')
        await fs.writeFile(envPath, basicEnvContent, 'utf8')
      } catch (error: any) {
        errors.push(`Failed to create .env.dev: ${error.message}`)
      }

      return NextResponse.json({
        success: true,
        message: 'Project reset successfully (manual fallback)',
        details: {
          removedFiles,
          errors: errors.length > 0 ? errors : undefined,
          message:
            'Project has been reset to initial state. You can now go through the setup wizard again.',
        },
      })
    }
  } catch (error: any) {
    console.error('Error resetting project:', error)
    return NextResponse.json(
      { error: 'Failed to reset project', details: error.message },
      { status: 500 },
    )
  }
}
